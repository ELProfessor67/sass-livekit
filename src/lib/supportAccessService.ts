import { supabase } from '@/integrations/supabase/client';
import { createHash } from 'crypto';

export interface SupportSession {
  id: string;
  admin_user_id: string;
  target_user_id: string;
  reason: string;
  duration_minutes: number;
  scoped_token: string;
  status: 'active' | 'expired' | 'revoked' | 'completed';
  expires_at: string;
  started_at: string;
  ended_at?: string;
  created_at: string;
  updated_at: string;
}

export interface AuditLogEntry {
  id: string;
  session_id?: string;
  admin_user_id: string;
  target_user_id?: string;
  action_type: string;
  resource_type?: string;
  resource_id?: string;
  details?: any;
  ip_address?: string;
  user_agent?: string;
  created_at: string;
}

export interface ScopedTokenInfo {
  is_valid: boolean;
  session_id?: string;
  admin_user_id?: string;
  target_user_id?: string;
  expires_at?: string;
}

export class SupportAccessService {
  private static instance: SupportAccessService;

  public static getInstance(): SupportAccessService {
    if (!SupportAccessService.instance) {
      SupportAccessService.instance = new SupportAccessService();
    }
    return SupportAccessService.instance;
  }

  /**
   * Create a new support access session
   */
  async createSupportSession(
    adminUserId: string,
    targetUserId: string,
    reason: string,
    durationMinutes: number = 30
  ): Promise<{ success: boolean; session?: SupportSession; token?: string; message?: string }> {
    try {
      // Validate duration
      if (durationMinutes < 15 || durationMinutes > 120) {
        return { success: false, message: 'Duration must be between 15 and 120 minutes' };
      }

      // Check if admin has permission
      const { data: adminUser, error: adminError } = await supabase
        .from('users')
        .select('role')
        .eq('id', adminUserId)
        .single();

      if (adminError || !adminUser || adminUser.role !== 'admin') {
        return { success: false, message: 'Only admins can create support sessions' };
      }

      // Check if target user exists and is not admin
      const { data: targetUser, error: targetError } = await supabase
        .from('users')
        .select('role')
        .eq('id', targetUserId)
        .single();

      if (targetError || !targetUser) {
        return { success: false, message: 'Target user not found' };
      }

      if (targetUser.role === 'admin') {
        return { success: false, message: 'Cannot create support session for admin users' };
      }

      // Check for existing active session
      const { data: existingSession } = await supabase
        .from('support_sessions')
        .select('id')
        .eq('admin_user_id', adminUserId)
        .eq('target_user_id', targetUserId)
        .eq('status', 'active')
        .single();

      if (existingSession) {
        return { success: false, message: 'Active support session already exists for this user' };
      }

      // Calculate expiration time
      const expiresAt = new Date();
      expiresAt.setMinutes(expiresAt.getMinutes() + durationMinutes);

      // Create support session
      const { data: session, error: sessionError } = await supabase
        .from('support_sessions')
        .insert({
          admin_user_id: adminUserId,
          target_user_id: targetUserId,
          reason,
          duration_minutes: durationMinutes,
          scoped_token: '', // Will be generated by database function
          expires_at: expiresAt.toISOString(),
        })
        .select()
        .single();

      if (sessionError) {
        console.error('Error creating support session:', sessionError);
        return { success: false, message: 'Failed to create support session' };
      }

      // Generate scoped token using database function
      const { data: tokenData, error: tokenError } = await supabase
        .rpc('generate_scoped_token', { session_uuid: session.id });

      if (tokenError) {
        console.error('Error generating scoped token:', tokenError);
        return { success: false, message: 'Failed to generate scoped token' };
      }

      // Update session with the generated token
      const { data: updatedSession, error: updateError } = await supabase
        .from('support_sessions')
        .update({ scoped_token: tokenData })
        .eq('id', session.id)
        .select()
        .single();

      if (updateError) {
        console.error('Error updating session with token:', updateError);
        return { success: false, message: 'Failed to update session with token' };
      }

      // Log audit event
      await this.logAuditEvent({
        session_id: session.id,
        admin_user_id: adminUserId,
        target_user_id: targetUserId,
        action_type: 'support_access_started',
        details: {
          reason,
          duration_minutes: durationMinutes,
          expires_at: expiresAt.toISOString(),
        },
      });

      return {
        success: true,
        session: updatedSession as SupportSession,
        token: tokenData,
      };
    } catch (error) {
      console.error('Error in createSupportSession:', error);
      return { success: false, message: 'An error occurred while creating support session' };
    }
  }

  /**
   * Validate a scoped token
   */
  async validateScopedToken(token: string): Promise<ScopedTokenInfo> {
    try {
      const { data, error } = await supabase
        .rpc('validate_scoped_token', { token_input: token });

      if (error) {
        console.error('Error validating scoped token:', error);
        return { is_valid: false };
      }

      if (!data || data.length === 0) {
        return { is_valid: false };
      }

      const result = data[0];
      return {
        is_valid: result.is_valid,
        session_id: result.session_id,
        admin_user_id: result.admin_user_id,
        target_user_id: result.target_user_id,
        expires_at: result.expires_at,
      };
    } catch (error) {
      console.error('Error in validateScopedToken:', error);
      return { is_valid: false };
    }
  }

  /**
   * End a support session
   */
  async endSupportSession(
    sessionId: string,
    adminUserId: string,
    reason: 'completed' | 'revoked' = 'completed'
  ): Promise<{ success: boolean; message?: string }> {
    try {
      // Update session status
      const { error: updateError } = await supabase
        .from('support_sessions')
        .update({
          status: reason,
          ended_at: new Date().toISOString(),
        })
        .eq('id', sessionId)
        .eq('admin_user_id', adminUserId);

      if (updateError) {
        console.error('Error ending support session:', updateError);
        return { success: false, message: 'Failed to end support session' };
      }

      // Revoke associated tokens
      const { error: revokeError } = await supabase
        .from('scoped_tokens')
        .update({ is_revoked: true })
        .eq('session_id', sessionId);

      if (revokeError) {
        console.error('Error revoking tokens:', revokeError);
        // Don't fail the operation for this
      }

      // Log audit event
      await this.logAuditEvent({
        session_id: sessionId,
        admin_user_id: adminUserId,
        action_type: reason === 'completed' ? 'support_access_ended' : 'support_access_revoked',
      });

      return { success: true };
    } catch (error) {
      console.error('Error in endSupportSession:', error);
      return { success: false, message: 'An error occurred while ending support session' };
    }
  }

  /**
   * Get active support sessions for an admin
   */
  async getActiveSupportSessions(adminUserId: string): Promise<SupportSession[]> {
    try {
      const { data, error } = await supabase
        .from('support_sessions')
        .select(`
          *,
          admin_user:admin_user_id(name, contact),
          target_user:target_user_id(name, contact, company)
        `)
        .eq('admin_user_id', adminUserId)
        .eq('status', 'active')
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching support sessions:', error);
        return [];
      }

      return data as SupportSession[];
    } catch (error) {
      console.error('Error in getActiveSupportSessions:', error);
      return [];
    }
  }

  /**
   * Get support session by ID
   */
  async getSupportSession(sessionId: string): Promise<SupportSession | null> {
    try {
      const { data, error } = await supabase
        .from('support_sessions')
        .select('*')
        .eq('id', sessionId)
        .single();

      if (error) {
        console.error('Error fetching support session:', error);
        return null;
      }

      return data as SupportSession;
    } catch (error) {
      console.error('Error in getSupportSession:', error);
      return null;
    }
  }

  /**
   * Log an audit event
   */
  async logAuditEvent(params: {
    session_id?: string;
    admin_user_id?: string;
    target_user_id?: string;
    action_type: string;
    resource_type?: string;
    resource_id?: string;
    details?: any;
    ip_address?: string;
    user_agent?: string;
  }): Promise<string | null> {
    try {
      const { data, error } = await supabase
        .rpc('log_audit_event', {
          p_session_id: params.session_id || null,
          p_admin_user_id: params.admin_user_id || null,
          p_target_user_id: params.target_user_id || null,
          p_action_type: params.action_type,
          p_resource_type: params.resource_type || null,
          p_resource_id: params.resource_id || null,
          p_details: params.details || null,
          p_ip_address: params.ip_address || null,
          p_user_agent: params.user_agent || null,
        });

      if (error) {
        console.error('Error logging audit event:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in logAuditEvent:', error);
      return null;
    }
  }

  /**
   * Get audit logs for a session
   */
  async getAuditLogs(sessionId: string): Promise<AuditLogEntry[]> {
    try {
      const { data, error } = await supabase
        .from('audit_log')
        .select('*')
        .eq('session_id', sessionId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching audit logs:', error);
        return [];
      }

      return data as AuditLogEntry[];
    } catch (error) {
      console.error('Error in getAuditLogs:', error);
      return [];
    }
  }

  /**
   * Clean up expired sessions (can be called periodically)
   */
  async cleanupExpiredSessions(): Promise<number> {
    try {
      const { data, error } = await supabase
        .rpc('cleanup_expired_support_sessions');

      if (error) {
        console.error('Error cleaning up expired sessions:', error);
        return 0;
      }

      return data || 0;
    } catch (error) {
      console.error('Error in cleanupExpiredSessions:', error);
      return 0;
    }
  }

  /**
   * Get user info for scoped access
   */
  async getUserForScopedAccess(targetUserId: string): Promise<any> {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', targetUserId)
        .single();

      if (error) {
        console.error('Error fetching user for scoped access:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in getUserForScopedAccess:', error);
      return null;
    }
  }
}
